####### grammar ########
expr            : term ((PLUS|MINUS) term)*
term            : factor ((MUL|DIV) factor)*
factor          : INT|FLOAT

################################# dao.py ###############################

Here's a brief explanation of each class and function in the provided code, following the order they appear:

1. **`Error` Class**: Represents a generic error with a name, location, and details.

2. **`IllegalCharError` Class**: Specifies an error for illegal or unexpected characters in the input.

3. **`InvalidSyntaxError` Class**: Indicates an error due to syntax that doesn't conform to the language's rules.

4. **`RTError` Class**: Captures runtime errors, including their context for better error tracking.

5. **`Position` Class**: Manages the position within the source code, tracking line and column numbers.

6. **`Token` Class**: Represents a syntactic token with a type, value, and positional information.

7. **`Lexer` Class**: Analyzes the source code text and converts it into a list of tokens.


8. **`make_tokens` Method**: Generates tokens from the source code by categorizing characters and sequences.

9. **`make_number` Method**: Handles the creation of number tokens, detecting integers and floats.

10. **`NumberNode` Class**: Represents numeric literals in the abstract syntax tree (AST).

11. **`BinOpNode` Class**: Represents binary operations (like addition, subtraction) in the AST with two operands.

12. **`UnaryOpNode` Class**: Represents unary operations (like negation) in the AST with a single operand.

13. **`ParseResult` Class**: Used by the parser to manage the result of parsing operations, including errors.

14. **`Parser` Class**: Parses a sequence of tokens into an AST based on the language's grammar.


15. **`atom`, `factor`, `term`, `expr` Methods**: These parsing functions implement the grammar rules for expressions.

16. **`bin_op` Method**: A utility method for handling binary operations during parsing.

17. **`RTResult` Class**: Manages the result of runtime operations, handling both values and errors.

18. **`Number` Class**: Represents numeric values during interpretation, supporting basic arithmetic operations.

19. **`Context` Class**: Maintains the context of execution, such as the current function or program scope.

20. **`Interpreter` Class**: Visits nodes in the AST to interpret the program and produce a result.

21. **`run` Function**: The entry point for executing the interpreter, coordinating lexing, parsing, and interpretation.


                ###################################
This code forms the core of a simple interpreted programming language, functioning through several key stages: lexing, parsing, interpreting, and error handling.

1. **Lexing**: The `Lexer` class processes the input text, converting it into a sequence of tokens (`Token` class instances) based on predefined rules (e.g., recognizing numbers, operators). It handles characters one by one, categorizing them into tokens like integers, floats, and arithmetic symbols.

2. **Parsing**: The `Parser` class takes the tokens from the lexer and constructs an Abstract Syntax Tree (AST) by applying the grammar of the language. It organizes tokens into a hierarchical structure that represents the syntactic structure of the code, using nodes (`NumberNode`, `BinOpNode`, `UnaryOpNode`) for literals and operations.

3. **Interpreting**: The `Interpreter` class traverses the AST and evaluates the expressions. It performs the computations defined by the nodes in the AST, effectively running the program represented by the AST.

4. **Error Handling**: Error classes (`Error`, `IllegalCharError`, `InvalidSyntaxError`, `RTError`) are used to represent and report issues encountered during lexing, parsing, and interpreting. They provide detailed information about the nature and location of the error in the source code.

5. **Execution Flow**: The `run` function ties everything together. It invokes the lexer to tokenize the input, the parser to generate the AST from the tokens, and finally, the interpreter to execute the program represented by the AST. Errors at any stage are captured and reported, providing feedback about issues like illegal characters, syntax errors, or runtime problems.

Overall, the code provides a streamlined process for interpreting a simple programming language, from reading and tokenizing the input text to parsing it into an AST and executing it, all while handling errors gracefully.

########################### dao.py ##################################
                            ##
                            ##
                            ##
                            ##
                            ##
                            ##
################## highlight_error_location #########################

Calculate Indices: The function first calculates the start (idx_start) and end (idx_end) indices of the line or lines where the error occurred in the input text. This is done by finding the positions of newline characters (\n) before and after the error's location.
Generate Line(s) with Error: For each line involved in the error (from pos_start.ln to pos_end.ln), the function extracts the line from the input text and calculates where to start and end highlighting (col_start and col_end).
Highlight Error: It then appends this line to the result string and adds a new line underneath with caret symbols (^) pointing to the exact column(s) where the error was detected. This visual cue helps the user quickly identify the error's location.
Handle Tabs and Multiline: The function replaces tabs with spaces for consistent alignment and handles errors that span multiple lines by repeating this process for each line involved

################## highlight_error_location #########################