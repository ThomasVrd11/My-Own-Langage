####### grammar ########
expr            : term ((PLUS|MINUS) term)*
term            : factor ((MUL|DIV) factor)*
factor          : INT|FLOAT

VAR             variable_name           =           (expr)
keyword             identifier          equals          

################################# dao.py ###############################

1. **`Error` Class**: This foundational class represents errors that can occur within the interpreter. It includes the error's type, a detailed message, and the position in the source code where the error was detected, providing a framework for reporting errors in a structured way.

2. **`IllegalCharError` Class**: Derived from the `Error` class, this specifies errors caused by characters in the source code that are not recognized by the language's grammar, such as unsupported symbols or punctuation.

3. **`InvalidSyntaxError` Class**: This class represents errors that occur when the code violates the syntactic rules of the language, such as missing operators, unmatched parentheses, or incorrect statement structures.

4. **`RTError` Class**: Stands for "Runtime Error" and captures errors that occur during the execution of the program, such as division by zero or accessing undefined variables. It includes context to help trace the error back to its source in the code.

5. **`Position` Class**: Keeps track of the current position in the source code being processed, including the index in the text, the current line, and column numbers, as well as the filename and the full text for reference. This is crucial for error reporting and token positioning.

6. **`Token` Class**: Represents the basic building blocks of the language, created by the lexer. Each token has a type (such as integer, operator, parenthesis) and optionally a value (like the specific number for an integer token). Tokens also carry their position in the source code for error tracking.

7. **`Lexer` Class**: Analyzes the input source code text character by character to produce a list of tokens. It categorizes segments of text according to the language's rules, effectively breaking down the code into manageable pieces for parsing.

8. **`make_tokens` Method**: Within the `Lexer` class, this method iterates over the source text, converting it into tokens based on their syntactic role, and handles whitespace and unrecognized characters gracefully.

9. **`make_number` Method**: A specialized lexer method for parsing numbers, including integers and floats. It accumulates digits and decimal points to construct numeric tokens, taking care to handle the decimal point correctly.

10. **`NumberNode` Class**: In the AST, this node represents literal numbers. It holds a token corresponding to the number and is used in the tree to represent numeric values in expressions.

11. **`BinOpNode` Class**: Represents binary operations in the AST, such as addition or multiplication, with child nodes for the left and right operands and the operation itself, reflecting the structure of expressions like `a + b`.

12. **`UnaryOpNode` Class**: Represents unary operations, which have a single operand, such as negation. It includes the operator and a child node for the operand, capturing operations like `-a`.

13. **`ParseResult` Class**: Used by the parser to encapsulate the outcome of parsing operations. It can hold either a successfully parsed node or an error, providing a mechanism for error propagation during parsing.

14. **`Parser` Class**: Takes the list of tokens produced by the lexer and constructs an AST by applying the language's grammar rules. It organizes tokens into a hierarchical structure that represents the program's syntax.

15. **Parsing Methods (`atom`, `factor`, `term`, `expr`)**: These methods within the `Parser` class implement the grammar of the language, defining how expressions are broken down into their components and structured in the AST.

16. **`bin_op` Method**: A utility method in the parser for handling binary operations, abstracting common logic for parsing expressions with binary operators to reduce redundancy.

17. **`RTResult` Class**: Similar to `ParseResult`, but used during interpretation to manage the outcomes of executing AST nodes, including both the execution results and any runtime errors.

18. **`Number` Class**: Represents evaluated numeric values during interpretation, providing methods for basic arithmetic operations and enabling the interpreter to execute mathematical expressions.

19. **`Context` Class**: Maintains the current context of execution, such as the current function or variable scope, providing a runtime environment for executing code and tracking the location in the source code for error reporting.

20. **`Interpreter` Class**: Visits each node in the AST and executes its corresponding operation, effectively running the program represented by the AST. It uses visitor patterns to handle different types of nodes.

21. **`run` Function**: The main entry point for the interpreter, which coordinates the lexing of the input code into tokens, parsing of tokens into an AST, and finally interpreting the AST to execute the program. It also handles and reports any errors encountered along the way.

                ###################################
This code forms the core of a simple interpreted programming language, functioning through several key stages: lexing, parsing, interpreting, and error handling.

1. **Lexing**: The `Lexer` class processes the input text, converting it into a sequence of tokens (`Token` class instances) based on predefined rules (e.g., recognizing numbers, operators). It handles characters one by one, categorizing them into tokens like integers, floats, and arithmetic symbols.

2. **Parsing**: The `Parser` class takes the tokens from the lexer and constructs an Abstract Syntax Tree (AST) by applying the grammar of the language. It organizes tokens into a hierarchical structure that represents the syntactic structure of the code, using nodes (`NumberNode`, `BinOpNode`, `UnaryOpNode`) for literals and operations.

3. **Interpreting**: The `Interpreter` class traverses the AST and evaluates the expressions. It performs the computations defined by the nodes in the AST, effectively running the program represented by the AST.

4. **Error Handling**: Error classes (`Error`, `IllegalCharError`, `InvalidSyntaxError`, `RTError`) are used to represent and report issues encountered during lexing, parsing, and interpreting. They provide detailed information about the nature and location of the error in the source code.

5. **Execution Flow**: The `run` function ties everything together. It invokes the lexer to tokenize the input, the parser to generate the AST from the tokens, and finally, the interpreter to execute the program represented by the AST. Errors at any stage are captured and reported, providing feedback about issues like illegal characters, syntax errors, or runtime problems.

Overall, the code provides a streamlined process for interpreting a simple programming language, from reading and tokenizing the input text to parsing it into an AST and executing it, all while handling errors gracefully.

########################### dao.py ##################################
                            ##
                            ##
                            ##
                            ##
                            ##
                            ##
################## highlight_error_location #########################

Calculate Indices: The function first calculates the start (idx_start) and end (idx_end) indices of the line or lines where the error occurred in the input text. This is done by finding the positions of newline characters (\n) before and after the error's location.
Generate Line(s) with Error: For each line involved in the error (from pos_start.ln to pos_end.ln), the function extracts the line from the input text and calculates where to start and end highlighting (col_start and col_end).
Highlight Error: It then appends this line to the result string and adds a new line underneath with caret symbols (^) pointing to the exact column(s) where the error was detected. This visual cue helps the user quickly identify the error's location.
Handle Tabs and Multiline: The function replaces tabs with spaces for consistent alignment and handles errors that span multiple lines by repeating this process for each line involved

################## highlight_error_location #########################