####### grammar ########
expr            : KEYWORD:VAR IDENTIFIER EQUAL expr
                : term ((PLUS|MINUS)term)*
term            : factor ((MUL|DIV)factor)*
factor          : (PLUS|MINUS) factor
                : power
power           : atom (POW factor)*
atom            : INT|FLOAT|IDENTIFIER
                : LPAREN expr RPAREN

VAR variable_name = (expr)
keyword identifier equals

####### input variables examples
Dao > VAR a = 3
3
Dao > VAR b = 12
12
Dao > a * b
36
Dao > a + (a * b)
39
Dao > 4 + (VAR x = 6)
10
Dao > VAR e = VAR o = VAR l = 12
12
Dao > e
12
Dao > l
12
#######

################################# dao.py ###############################

1. **`Error` Class**: Defines a generic error, including start and end positions, an error name, and detailed message. Useful for reporting errors with specific information about their occurrence in the source code.

2. **`IllegalCharError` Class**: Specialized error for handling illegal characters in the source code, inheriting from the `Error` class and providing a specific error name ('Illegal Character').

3. **`InvalidSyntaxError` Class**: Represents syntax-related errors in the code, extending the `Error` class to provide syntax-specific error messages.

4. **`RTError` Class**: Captures runtime errors that occur during the execution of the program, including the context in which the error happened, and supports generating a traceback for debugging.

5. **`Position` Class**: Tracks the position within the source code being interpreted, including index, line, column, file name, and the entire file text, useful for pinpointing error locations and token positioning.

6. **`Token` Class**: Represents the smallest units of meaningful text (like numbers, operators, and identifiers), including type, value, and position, serving as the building blocks for parsing.

7. **`Lexer` Class**: Processes the input text to produce a list of tokens, handling different types of characters and sequences as defined by the language's syntax.

8. **`make_tokens` Method**: Within `Lexer`, this method iterates over the input text, categorizing segments into tokens based on the language's lexical rules.

9. **`make_number` Method**: A `Lexer` utility for parsing numbers (integers and floats) from the text, handling the accumulation of digits and decimal points.

10. **`make_identifier` Method**: Identifies and creates tokens for identifiers (like variable names) and keywords by accumulating letter and digit characters.

11. **`NumberNode` Class**: A node in the AST representing numeric literals, holding a token for the number and its position.

12. **`VarAccessNode` Class**: Represents access to a variable in the AST, containing a token for the variable name and its position.

13. **`VarAssignNode` Class**: Represents variable assignment in the AST, holding tokens for the variable name and the value assigned to it, along with their positions.

14. **`BinOpNode` Class**: Represents binary operations (like addition, subtraction) in the AST, with nodes for the left and right operands and the operation token.

15. **`UnaryOpNode` Class**: Represents unary operations (like negation) in the AST with a single operand node and the operation token.

16. **`ParseResult` Class**: Used by the parser to encapsulate the result of parsing operations, including any errors and the node produced.

17. **`Parser` Class**: Takes a list of tokens and constructs an AST by applying the grammar rules of the language.

18. **`atom`, `power`, `factor`, `term`, `expr` Methods**: These parsing functions within `Parser` implement the grammar rules for expressions, organizing tokens into an AST.

19. **`bin_op` Method**: A utility method for handling binary operations in the parsing process, abstracting common logic to reduce redundancy.

20. **`RTResult` Class**: Manages the result of runtime operations during interpretation, holding the value produced or any errors.

21. **`Number` Class**: Represents numeric values during interpretation, supporting arithmetic operations and setting the execution context and position.

22. **`Context` Class**: Maintains the execution context, like the current function or program scope, and holds a symbol table for variable tracking.

23. **`SymbolTable` Class**: Stores and manages symbols (like variables) and their values within a given context, supporting variable lookup, assignment, and deletion.

24. **`Interpreter` Class**: Visits each node in the AST to evaluate the program, performing operations defined by the nodes and producing a result.

25. **`run` Function**: Coordinates the entire process from lexing to interpretation, setting up a global symbol table and executing the program, returning the result or any errors encountered.

                ###################################

1. **Lexing**: The `Lexer` class processes the input text to produce tokens (`Token` instances), recognizing not just numbers and operators, but also identifiers and keywords thanks to the inclusion of `LETTERS` and `LETTERS_DIGITS` in its logic. It categorizes characters into appropriate tokens, including handling of variable names and language keywords.

2. **Parsing**: The `Parser` class builds an Abstract Syntax Tree (AST) from the tokens generated by the lexer. It uses a broader set of nodes, including `NumberNode` for numeric literals, `BinOpNode` for binary operations, and `UnaryOpNode` for unary operations, as well as `VarAccessNode` and `VarAssignNode` for variable access and assignment. This structure allows the representation of more complex language constructs, including variable usage and manipulation.

3. **Interpreting**: The `Interpreter` class walks through the AST to evaluate the program. In addition to computing expressions, it also interprets variable assignments and accesses by interacting with a `SymbolTable` (not explicitly mentioned before but implied by the presence of variable-related nodes), which manages variable names and their values within the execution context.

4. **Error Handling**: Enhanced error handling is provided by specialized error classes (`Error`, `IllegalCharError`, `InvalidSyntaxError`, `RTError`), each designed for specific types of errors encountered during the different stages (lexing, parsing, runtime). The `RTError` class, in particular, includes a method to generate a traceback, providing a detailed path of execution leading up to the error, which is crucial for debugging.

5. **Execution Flow**: The `run` function orchestrates the entire process, starting with lexing the input to generate tokens, parsing these tokens into an AST, and finally interpreting the AST to execute the program. This function also establishes a global execution context and a symbol table (`global_symbol_table`), ensuring variables and their values are managed and accessible throughout the program's execution. Errors detected at any stage are systematically reported, offering clear insights into issues like undefined variables, syntax mistakes, or illegal characters, enhancing the developer's experience by making error diagnosis more straightforward.

########################### dao.py ##################################
                            ##
                            ##
                            ##
                            ##
                            ##
                            ##
################## highlight_error_location #########################

Calculate Indices: The function first calculates the start (idx_start) and end (idx_end) indices of the line or lines where the error occurred in the input text. This is done by finding the positions of newline characters (\n) before and after the error's location.
Generate Line(s) with Error: For each line involved in the error (from pos_start.ln to pos_end.ln), the function extracts the line from the input text and calculates where to start and end highlighting (col_start and col_end).
Highlight Error: It then appends this line to the result string and adds a new line underneath with caret symbols (^) pointing to the exact column(s) where the error was detected. This visual cue helps the user quickly identify the error's location.
Handle Tabs and Multiline: The function replaces tabs with spaces for consistent alignment and handles errors that span multiple lines by repeating this process for each line involved

################## highlight_error_location #########################